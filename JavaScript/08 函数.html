<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- <script>
    // 函数:封装了 一段可以被重复执行调用的代码块;目的:让大量代码重复使用
    // 使用:声明函数和调用函数
    // 1 声明函数
    /* function 函数名(){
      // 函数体
    } */
    function sayHi() {
      console.log('Hi~~');
    }
    // 注意点:(1)function 声明函数的关键字 全部小写;(2)函数是做某件事情,函数名一般是动词;(3)函数不调用自己不执行
    // 2 调用函数  
    // 函数名();
    sayHi();
    // 注意点:调用函数时不要忘记加小括号()
    // 求1-100之间的累加和
    /* function getSum() {
      var sum = 0;
      for (var i = 1; i <= 100; i++) {
        sum += i;
      } console.log(sum);
    }
    getSum();
    getSum(); */
    // 函数的参数
    // 1.函数可以重复相同的代码
    /*  function cook() {
       console.log('酸辣土豆丝');
     }
     cook();
     cook();
     cook(); */
    // 2.利用函数的参数实现函数重复不同的代码
    /* function 函数名(形参1,形参2...){ // 在声明函数的小括号里面是形参(形式上的参数)

    }
    函数名(实参1,实参2...); // 在函数调用的小括号里面是实参(实际的参数)
 */
    // 3. 形参和实参的执行过程
    function cook(aru) { // 形参是接收实参的 aru='酸辣土豆丝' 形参类似于一个变量
      console.log(aru);
    }
    cook('酸辣土豆丝');
    cook('大肘子');
    // 函数的参数可以有,也可以没有,个数不限 (参数作用:在函数内部某些值不能固定,可以通过参数在调用函数时传递不同的值进去)

    // 案例1 利用函数求任意两个数的和
    /* function getSum(num1, num2) {
      console.log(num1 + num2);

    }
    getSum(1, 3);
    getSum(3, 8); */
    // 案例2 利用函数求任意两个数之间的和
    /* function getSums(start, end) {
      var sum = 0;
      for (i = start; i <= end; i++) {
        sum += i
      }
      console.log(sum);

    }
    getSums(1, 100);
    getSums(1, 10); */
    // 注意点:(1)多个参数之间用逗号,隔开;(2)形参可以看做是不用声明的变量

    // 函数形参 实参个数匹配
    /*   function getSum3(num1, num2) {
        console.log(num1 + num2);
  
      }
      // 1 如果实参的个数和形参的个数一致,则正常输出结果
      getSum3(1, 2);
      // 2 如果实参的个数多于形参的个数,会取到形参的个数
      getSum3(1, 2, 3);
      // 3 如果实参的个数小于形参的个数,多余的形参 定义为 undefined,最终的结果:NaN
      // 形参可以看做是不用声明的变量 num2 是一个变量但是没有接受值,结果就说undefined
      getSum3(1); // NaN */
    // 建议 尽量让形参与实参的个数相匹配

    // 函数是做某件事或实现某种功能
    // 函数的返回值 return 
    // 1 格式
    /* function 函数名(){
      return 需要返回的结果;
    }
    函数名(); */
    //(1)函数只是实现某种功能,最终结果要返回给函数的调用者 函数名(),通过return实现;(2)只要函数遇到return,就把后面的结果返回给函数的调用者,函数名()=return后面的结果
    // 2 代码验证
    /*  function getResult() {
       return 666;
     }
     getResult(); // getResult() = 666
     console.log(getResult());
 
     function cook1(aru) {
       return aru;
     }
     console.log(cook1('牛排')); */
    // 3 求任意两个数的和

    function getSum4(num1, num2) {
      return num1 + num2;
    }
    console.log(getSum4(1, 2));

    // 案例 利用函数求任意两个数的最大值
    function getMax(num1, num2) {
      // if (num1 > num2) {
      //   return num1;
      // } else {
      //   return num2;
      // }
      return num1 > num2 ? num1 : num2;
    }
    console.log(getMax(78, 21));
    console.log(getMax(28, 21));
    // 案例 利用函数求任意一个数组中的最大值
    function getArrMax(arr) {// arr 接收一个数组
      var max = arr[0];
      for (var i = 1; i <= arr.length; i++) {
        if (arr[i] > max) {
          max = arr[i];
        }
      }
      return max;
    }
    // getArrMax([5, 2, 99, 101, 67, 77]); // 实参是一个数组送过去
    // 在实际开发中,经常用一个变量来接受,函数的返回结果,使用更简单
    // var re=getArrMax([5, 2, 99, 101, 67, 77]);
    var re = getArrMax([2, 99, 198, 22, 223, 456])
    console.log(re);

    // 函数返回值注意事项
    //1 return 终止函数
    function getSum5(num1, num2) {
      return num1 + num2; // return后面的代码不会被执行
      alert('我是不会被执行的')
    }
    console.log(getSum5(1, 2));
    // 2 return 只能返回一个值
    function fn(num1, num2) {
      return num1, num2; // 返回的结果是最后一个值
    }
    console.log(fn(1, 2));// 2
    //3 我们求任意两个数的加减乘除结果
    function getResult1(num1, num2) {
      return [num1 + num2, num1 - num2, num1 * num2, num1 / num2]
    }
    var re = getResult1(1, 2); // 返回的是一个数组
    console.log(re);
    // 4  函数如果有return 则返回的是return后面的值,如果函数没有return 则返回undefined
    function fun1() {
      return 666;
    }
    console.log(fun1()); // 666
    function fun2() {
      
    }
    console.log(fun2()); // undefined
    // break continue  return 的区别

  </script> -->
  <script>
    // arguments 的使用 只有函数才有arguments 而且是每个函数都已经内置好了这个arguments
    function fn3() {
      console.log(arguments); // 里面存储了所有传递过来的实参
      console.log(arguments.length);
      console.log(arguments[2]);
      // 可以按照数组的方式 遍历arguments
      for (var i = 1; i < arguments.length; i++) {
        console.log(arguments[i]);
      }
    }
    fn3(1, 2, 3);
    fn3(1, 2, 3, 4, 5);
    // 伪数组 并不是真正意义上的数组
    // 1 具有数组的 length属性
    // 2 按照索引的方式进行存储的
    // 3 没有真正数组的一些方法 pop() push()等等

    // 利用函数求任意个数的最大值
    function getMax() { // arguments=[1,2,3]
      var max = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        if (arguments[i] > max) {
          max = arguments[i]
        }
      }
      return max;

    }
    console.log(getMax(1, 2, 3));
    console.log(getMax(1, 2, 3, 4, 5, 6, 7));
    console.log(getMax(1, 2, 3, 66, 77, 88));
    console.log(getMax(1, 2, 3, 4, 5, 6, 77, 8, 8, 99, 998));

    // 利用函数封装方式,翻转任意一个数组
    function reverse(arr) {
      var newArr = [];
      for (var i = arr.length - 1; i >= 0; i--) {
        newArr[newArr.length] = arr[i];
      }
      return newArr;

    }
    var arr1 = reverse([1, 2, 3, 4, 5, 6, 7]);
    console.log(arr1);
    var arr2 = reverse(['red', 'black', 'blue', '伟伟'])
    console.log(arr2);

    // 利用函数封装方式,对数组排序--冒泡排序 sort 排序
    function sort(arr) {
      for (var i = 0; i <= arr.length-1; i++) {
        for (var j = 0; j < arr.length - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            var temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
        }
      }
      return arr;

    }
    var arr1 = sort([1, 4, 2, 9]);
    console.log(arr1);
    var arr2 = sort([9, 4, 2, 1, 3, 6, 5]);
    console.log(arr2);
    var arr3 = sort([5, 4, 3, 2, 1, 9, 8, 6, 7]);
    console.log(arr3);

    // 判断闰年
    function isRunYear(year) {
      // 如果是闰年 返回true,否则返回false
      var flag = false;
      if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
        flag = true;
      }
      return flag;
    }
    console.log(isRunYear(2000));
    console.log(isRunYear(1999));

    // 函数可以调用另外一个函数
    // function fn() {
    //   console.log(11);
    //   fn2();
    // }
    // fn();
    // function fn2(){
    //   console.log(22);
    // }
    function fn1() {
      console.log(111);
      fn2();
      console.log('fn1');
    }
    function fn2() {
      console.log(222);
      console.log('fn2');
    }
    fn1();  //  111 222 fn2 fn1

    // 用户输入年份,输出当前年份2月份的天数
    function backDay() {
      var year =prompt('请你输入年份');
      if(isRunYear(year)){ // 调用函数要加小括号
        alert('当前年份是闰年2月份有29天')
      } else{
        alert('当前年份是平年2月份有28天')
      }
       
    }
    backDay();
    // 判断闰年
    function isRunYear(year) {
      // 如果是闰年 返回true,否则返回false
      var flag = false;
      if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
        flag = true;
      }
      return flag;
    }
    

    // 函数的两种声明方式
    //1 利用函数关键字自定义函数(命名函数)
    function fn(){

    }
    fn();
    // 2 函数表达式(匿名函数)
    // var 变量名 = function(){};
    var fun=function(aru){
      console.log('我是函数表达式');
      console.log(aru);
    }
    fun('pink老师');
    //(1) fun是变量名 不是函数名
    //(2) 函数表达式声明方式跟声明变量差不多,只不过变量里面存的是值,而函数表达式里面存的是函数
    //(3) 函数表达式也可以进行传递参数



  </script>

</head>

<body>

</body>

</html>